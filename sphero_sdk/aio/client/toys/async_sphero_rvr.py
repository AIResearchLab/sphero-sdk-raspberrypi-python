#!/usr/bin/env python3
# This file is automatically generated!
# Toy Name:           Sphero RVR
# Prefix:             RV
# Command Count:      83
# Timestamp:          08/14/2019 @ 17:33:23.073715 (UTC)

import asyncio
from sphero_sdk.common.commands import api_and_shell
from sphero_sdk.common.commands import system_info
from sphero_sdk.common.commands import power
from sphero_sdk.common.commands import drive
from sphero_sdk.common.commands import sensor
from sphero_sdk.common.commands import connection
from sphero_sdk.common.commands import io


class AsyncSpheroRvr: 
    def __init__(self, dal): 
        self._dal = dal

    async def echo(self, data, target, timeout=None): 
        '''echo

        :param data: 
        :type data: array of uint8_ts (up to 16)
        :param uint8_t target: 1 or 2
        :param float timeout: maximum time to await a response

        :returns: data(uint8_t array)
        '''
        command_dict = api_and_shell.echo(data, target=target, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def get_main_application_version(self, target, timeout=None): 
        '''get_main_application_version

        :param uint8_t target: 1 or 2
        :param float timeout: maximum time to await a response

        :rtype: tuple
        :returns: major(uint16_t), minor(uint16_t), revision(uint16_t)
        '''
        command_dict = system_info.get_main_application_version(target=target, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def get_bootloader_version(self, target, timeout=None): 
        '''get_bootloader_version

        :param uint8_t target: 1 or 2
        :param float timeout: maximum time to await a response

        :rtype: tuple
        :returns: major(uint16_t), minor(uint16_t), revision(uint16_t)
        '''
        command_dict = system_info.get_bootloader_version(target=target, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def get_board_revision(self, timeout=None): 
        '''get_board_revision

        :param float timeout: maximum time to await a response

        :returns: revision(uint8_t)
        '''
        command_dict = system_info.get_board_revision(target=1, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def get_mac_address(self, timeout=None): 
        '''get_mac_address

        :param float timeout: maximum time to await a response

        :returns: mac_address(std::string)
        '''
        command_dict = system_info.get_mac_address(target=1, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def get_stats_id(self, timeout=None): 
        '''get_stats_id

        :param float timeout: maximum time to await a response

        :returns: stats_id(uint16_t)
        '''
        command_dict = system_info.get_stats_id(target=1, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def get_processor_name(self, target, timeout=None): 
        '''get_processor_name

        :param uint8_t target: 1 or 2
        :param float timeout: maximum time to await a response

        :returns: name(std::string)
        '''
        command_dict = system_info.get_processor_name(target=target, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def get_boot_reason(self, timeout=None): 
        '''get_boot_reason

        :param float timeout: maximum time to await a response

        :returns: boot_reason(uint8_t)
        '''
        command_dict = system_info.get_boot_reason(target=1, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def get_last_error_info(self, timeout=None): 
        '''get_last_error_info

        :param float timeout: maximum time to await a response

        :rtype: tuple
        :returns: file_name(uint8_t array), line_number(uint16_t), data(uint8_t array)
        '''
        command_dict = system_info.get_last_error_info(target=1, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def get_sku(self, timeout=None): 
        '''get_sku

        :param float timeout: maximum time to await a response

        :returns: sku(std::string)
        '''
        command_dict = system_info.get_sku(target=1, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def get_core_up_time_in_milliseconds(self, timeout=None): 
        '''get_core_up_time_in_milliseconds

        :param float timeout: maximum time to await a response

        :returns: up_time(uint64_t)
        '''
        command_dict = system_info.get_core_up_time_in_milliseconds(target=1, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def get_event_log_status(self, target, timeout=None): 
        '''get_event_log_status

        :param uint8_t target: 1 or 2
        :param float timeout: maximum time to await a response

        :rtype: tuple
        :returns: log_capacity(uint32_t), number_of_bytes_used(uint32_t), number_of_events_in_log(uint32_t)
        '''
        command_dict = system_info.get_event_log_status(target=target, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def get_event_log_data(self, offset, count, target, timeout=None): 
        '''get_event_log_data

        :param uint32_t offset:  
        :param uint32_t count:  
        :param uint8_t target: 1 or 2
        :param float timeout: maximum time to await a response

        :returns: log_data(uint8_t array)
        '''
        command_dict = system_info.get_event_log_data(offset, count, target=target, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def enable_sos_message_notify(self, is_enabled, timeout=None): 
        '''enable_sos_message_notify

        :param bool is_enabled:  
        :param float timeout: maximum time to await a response

        :returns: (None)
        '''
        command_dict = system_info.enable_sos_message_notify(is_enabled, target=1, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def on_sos_message_notify(self, handler=None, timeout=None): 
        '''sos_message_notify

        :param coroutine handler: called asynchronously, takes form handler(sosMessage)
        :param float timeout: maximum time to await a response

        :returns: Task (Future) from which `handler` will be called
        '''
        command_dict = system_info.on_sos_message_notify(target=1, timeout=timeout)
        command_dict['handler'] = handler
        return asyncio.ensure_future( 
            self._dal.on_command(**command_dict)
        )

    async def get_sos_message(self, timeout=None): 
        '''get_sos_message

        :param float timeout: maximum time to await a response

        :returns: sos_message(uint8_t)
        '''
        command_dict = system_info.get_sos_message(target=1, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def clear_sos_message(self, timeout=None): 
        '''clear_sos_message

        :param float timeout: maximum time to await a response

        :returns: (None)
        '''
        command_dict = system_info.clear_sos_message(target=1, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def enter_deep_sleep(self, seconds_until_deep_sleep, timeout=None): 
        '''enter_deep_sleep

        :param uint8_t seconds_until_deep_sleep:  seconds
        :param float timeout: maximum time to await a response

        :returns: (None)
        '''
        command_dict = power.enter_deep_sleep(seconds_until_deep_sleep, target=1, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def enter_soft_sleep(self, timeout=None): 
        '''enter_soft_sleep

        :param float timeout: maximum time to await a response

        :returns: (None)
        '''
        command_dict = power.enter_soft_sleep(target=1, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def wake(self, timeout=None): 
        '''wake

        :param float timeout: maximum time to await a response

        :returns: (None)
        '''
        command_dict = power.wake(target=1, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def get_battery_percentage(self, timeout=None): 
        '''get_battery_percentage

        :param float timeout: maximum time to await a response

        :returns: percentage(uint8_t)
        '''
        command_dict = power.get_battery_percentage(target=1, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def get_battery_voltage_state(self, timeout=None): 
        '''get_battery_voltage_state

        :param float timeout: maximum time to await a response

        :returns: state(uint8_t)
        '''
        command_dict = power.get_battery_voltage_state(target=1, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def on_will_sleep_notify(self, handler=None, timeout=None): 
        '''will_sleep_notify

        :param coroutine handler: called asynchronously, takes form handler()
        :param float timeout: maximum time to await a response

        :returns: Task (Future) from which `handler` will be called
        '''
        command_dict = power.on_will_sleep_notify(target=1, timeout=timeout)
        command_dict['handler'] = handler
        return asyncio.ensure_future( 
            self._dal.on_command(**command_dict)
        )

    async def on_did_sleep_notify(self, handler=None, timeout=None): 
        '''did_sleep_notify

        :param coroutine handler: called asynchronously, takes form handler()
        :param float timeout: maximum time to await a response

        :returns: Task (Future) from which `handler` will be called
        '''
        command_dict = power.on_did_sleep_notify(target=1, timeout=timeout)
        command_dict['handler'] = handler
        return asyncio.ensure_future( 
            self._dal.on_command(**command_dict)
        )

    async def enable_battery_voltage_state_change_notify(self, is_enabled, timeout=None): 
        '''enable_battery_voltage_state_change_notify

        :param bool is_enabled:  
        :param float timeout: maximum time to await a response

        :returns: (None)
        '''
        command_dict = power.enable_battery_voltage_state_change_notify(is_enabled, target=1, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def on_battery_voltage_state_change_notify(self, handler=None, timeout=None): 
        '''battery_voltage_state_change_notify

        :param coroutine handler: called asynchronously, takes form handler(state)
        :param float timeout: maximum time to await a response

        :returns: Task (Future) from which `handler` will be called
        '''
        command_dict = power.on_battery_voltage_state_change_notify(target=1, timeout=timeout)
        command_dict['handler'] = handler
        return asyncio.ensure_future( 
            self._dal.on_command(**command_dict)
        )

    async def get_battery_voltage_in_volts(self, reading_type, timeout=None): 
        '''get_battery_voltage_in_volts

        :param uint8_t reading_type:  
        :param float timeout: maximum time to await a response

        :returns: voltage(float)
        '''
        command_dict = power.get_battery_voltage_in_volts(reading_type, target=1, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def get_battery_voltage_state_thresholds(self, timeout=None): 
        '''get_battery_voltage_state_thresholds

        :param float timeout: maximum time to await a response

        :rtype: tuple
        :returns: critical_threshold(float), low_threshold(float), hysteresis(float)
        '''
        command_dict = power.get_battery_voltage_state_thresholds(target=1, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def get_current_sense_amplifier_current(self, amplifier_id, timeout=None): 
        '''get_current_sense_amplifier_current

        :param uint8_t amplifier_id:  
        :param float timeout: maximum time to await a response

        :returns: amplifier_current(float)
        '''
        command_dict = power.get_current_sense_amplifier_current(amplifier_id, target=1, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def raw_motors(self, left_mode, left_speed, right_mode, right_speed, timeout=None): 
        '''raw_motors

        :param uint8_t left_mode:  
        :param uint8_t left_speed:  
        :param uint8_t right_mode:  
        :param uint8_t right_speed:  
        :param float timeout: maximum time to await a response

        :returns: (None)
        '''
        command_dict = drive.raw_motors(left_mode, left_speed, right_mode, right_speed, target=2, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def reset_yaw(self, timeout=None): 
        '''reset_yaw

        :param float timeout: maximum time to await a response

        :returns: (None)
        '''
        command_dict = drive.reset_yaw(target=2, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def drive_with_heading(self, speed, heading, flags, timeout=None): 
        '''drive_with_heading

        :param uint8_t speed:  
        :param int16_t heading:  
        :param uint8_t flags: drive_flags 
        :param float timeout: maximum time to await a response

        :returns: (None)
        '''
        command_dict = drive.drive_with_heading(speed, heading, flags, target=2, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def set_stabilization(self, index, timeout=None): 
        '''set_stabilization

        :param uint8_t index:  
        :param float timeout: maximum time to await a response

        :returns: (None)
        '''
        command_dict = drive.set_stabilization(index, target=2, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def enable_gyro_max_notify(self, is_enabled, timeout=None): 
        '''enable_gyro_max_notify

        :param bool is_enabled:  
        :param float timeout: maximum time to await a response

        :returns: (None)
        '''
        command_dict = sensor.enable_gyro_max_notify(is_enabled, target=2, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def on_gyro_max_notify(self, handler=None, timeout=None): 
        '''gyro_max_notify

        :param coroutine handler: called asynchronously, takes form handler(flags)
        :param float timeout: maximum time to await a response

        :returns: Task (Future) from which `handler` will be called
        '''
        command_dict = sensor.on_gyro_max_notify(target=2, timeout=timeout)
        command_dict['handler'] = handler
        return asyncio.ensure_future( 
            self._dal.on_command(**command_dict)
        )

    async def configure_collision_detection(self, method, x_threshold, x_speed, y_threshold, y_speed, dead_time, timeout=None): 
        '''configure_collision_detection

        :param uint8_t method:  
        :param uint8_t x_threshold:  
        :param uint8_t x_speed:  
        :param uint8_t y_threshold:  
        :param uint8_t y_speed:  
        :param uint8_t dead_time:  
        :param float timeout: maximum time to await a response

        :returns: (None)
        '''
        command_dict = sensor.configure_collision_detection(method, x_threshold, x_speed, y_threshold, y_speed, dead_time, target=2, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def on_collision_detected_notify(self, handler=None, timeout=None): 
        '''collision_detected_notify

        :param coroutine handler: called asynchronously, takes form handler(accelerationX, accelerationY, accelerationZ, axis, powerX, powerY, speed, time)
        :param float timeout: maximum time to await a response

        :returns: Task (Future) from which `handler` will be called
        '''
        command_dict = sensor.on_collision_detected_notify(target=2, timeout=timeout)
        command_dict['handler'] = handler
        return asyncio.ensure_future( 
            self._dal.on_command(**command_dict)
        )

    async def reset_locator_x_and_y(self, timeout=None): 
        '''reset_locator_x_and_y

        :param float timeout: maximum time to await a response

        :returns: (None)
        '''
        command_dict = sensor.reset_locator_x_and_y(target=2, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def set_locator_flags(self, flags, timeout=None): 
        '''set_locator_flags

        :param uint8_t flags: locator_flags 
        :param float timeout: maximum time to await a response

        :returns: (None)
        '''
        command_dict = sensor.set_locator_flags(flags, target=2, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def get_bot_to_bot_infrared_readings(self, timeout=None): 
        '''get_bot_to_bot_infrared_readings

        :param float timeout: maximum time to await a response

        :returns: sensor_data(uint32_t)
        '''
        command_dict = sensor.get_bot_to_bot_infrared_readings(target=2, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def get_rgbc_sensor_values(self, timeout=None): 
        '''get_rgbc_sensor_values

        :param float timeout: maximum time to await a response

        :rtype: tuple
        :returns: red_channel_value(uint16_t), green_channel_value(uint16_t), blue_channel_value(uint16_t), clear_channel_value(uint16_t)
        '''
        command_dict = sensor.get_rgbc_sensor_values(target=1, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def magnetometer_calibrate_to_north(self, timeout=None): 
        '''magnetometer_calibrate_to_north

        :param float timeout: maximum time to await a response

        :returns: (None)
        '''
        command_dict = sensor.magnetometer_calibrate_to_north(target=2, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def on_magnetometer_north_yaw_notify(self, handler=None, timeout=None): 
        '''magnetometer_north_yaw_notify

        :param coroutine handler: called asynchronously, takes form handler(yawDirection)
        :param float timeout: maximum time to await a response

        :returns: Task (Future) from which `handler` will be called
        '''
        command_dict = sensor.on_magnetometer_north_yaw_notify(target=2, timeout=timeout)
        command_dict['handler'] = handler
        return asyncio.ensure_future( 
            self._dal.on_command(**command_dict)
        )

    async def start_robot_to_robot_infrared_broadcasting(self, far_code, near_code, timeout=None): 
        '''start_robot_to_robot_infrared_broadcasting

        :param uint8_t far_code:  
        :param uint8_t near_code:  
        :param float timeout: maximum time to await a response

        :returns: (None)
        '''
        command_dict = sensor.start_robot_to_robot_infrared_broadcasting(far_code, near_code, target=2, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def start_robot_to_robot_infrared_following(self, far_code, near_code, timeout=None): 
        '''start_robot_to_robot_infrared_following

        :param uint8_t far_code:  
        :param uint8_t near_code:  
        :param float timeout: maximum time to await a response

        :returns: (None)
        '''
        command_dict = sensor.start_robot_to_robot_infrared_following(far_code, near_code, target=2, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def stop_robot_to_robot_infrared_broadcasting(self, timeout=None): 
        '''stop_robot_to_robot_infrared_broadcasting

        :param float timeout: maximum time to await a response

        :returns: (None)
        '''
        command_dict = sensor.stop_robot_to_robot_infrared_broadcasting(target=2, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def on_robot_to_robot_infrared_message_received_notify(self, handler=None, timeout=None): 
        '''robot_to_robot_infrared_message_received_notify

        :param coroutine handler: called asynchronously, takes form handler(infraredCode)
        :param float timeout: maximum time to await a response

        :returns: Task (Future) from which `handler` will be called
        '''
        command_dict = sensor.on_robot_to_robot_infrared_message_received_notify(target=2, timeout=timeout)
        command_dict['handler'] = handler
        return asyncio.ensure_future( 
            self._dal.on_command(**command_dict)
        )

    async def get_ambient_light_sensor_value(self, timeout=None): 
        '''get_ambient_light_sensor_value

        :param float timeout: maximum time to await a response

        :returns: ambient_light_value(float)
        '''
        command_dict = sensor.get_ambient_light_sensor_value(target=1, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def stop_robot_to_robot_infrared_following(self, timeout=None): 
        '''stop_robot_to_robot_infrared_following

        :param float timeout: maximum time to await a response

        :returns: (None)
        '''
        command_dict = sensor.stop_robot_to_robot_infrared_following(target=2, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def start_robot_to_robot_infrared_evading(self, far_code, near_code, timeout=None): 
        '''start_robot_to_robot_infrared_evading

        :param uint8_t far_code:  
        :param uint8_t near_code:  
        :param float timeout: maximum time to await a response

        :returns: (None)
        '''
        command_dict = sensor.start_robot_to_robot_infrared_evading(far_code, near_code, target=2, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def stop_robot_to_robot_infrared_evading(self, timeout=None): 
        '''stop_robot_to_robot_infrared_evading

        :param float timeout: maximum time to await a response

        :returns: (None)
        '''
        command_dict = sensor.stop_robot_to_robot_infrared_evading(target=2, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def enable_color_detection_notify(self, is_enabled, interval, minimum_confidence_threshold, timeout=None): 
        '''enable_color_detection_notify

        :param bool is_enabled:  
        :param uint16_t interval:  milliseconds
        :param uint8_t minimum_confidence_threshold:  
        :param float timeout: maximum time to await a response

        :returns: (None)
        '''
        command_dict = sensor.enable_color_detection_notify(is_enabled, interval, minimum_confidence_threshold, target=1, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def on_color_detection_notify(self, handler=None, timeout=None): 
        '''color_detection_notify

        :param coroutine handler: called asynchronously, takes form handler(red, green, blue, confidence, colorClassificationId)
        :param float timeout: maximum time to await a response

        :returns: Task (Future) from which `handler` will be called
        '''
        command_dict = sensor.on_color_detection_notify(target=1, timeout=timeout)
        command_dict['handler'] = handler
        return asyncio.ensure_future( 
            self._dal.on_command(**command_dict)
        )

    async def get_current_detected_color_reading(self, timeout=None): 
        '''get_current_detected_color_reading

        :param float timeout: maximum time to await a response

        :returns: (None)
        '''
        command_dict = sensor.get_current_detected_color_reading(target=1, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def enable_color_detection(self, is_enabled, timeout=None): 
        '''enable_color_detection

        :param bool is_enabled:  
        :param float timeout: maximum time to await a response

        :returns: (None)
        '''
        command_dict = sensor.enable_color_detection(is_enabled, target=1, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def enable_robot_infrared_message_notify(self, is_enabled, timeout=None): 
        '''enable_robot_infrared_message_notify

        :param bool is_enabled:  
        :param float timeout: maximum time to await a response

        :returns: (None)
        '''
        command_dict = sensor.enable_robot_infrared_message_notify(is_enabled, target=2, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def send_infrared_message(self, infrared_code, front_strength, left_strength, right_strength, rear_strength, timeout=None): 
        '''send_infrared_message

        :param uint8_t infrared_code:  
        :param uint8_t front_strength:  
        :param uint8_t left_strength:  
        :param uint8_t right_strength:  
        :param uint8_t rear_strength:  
        :param float timeout: maximum time to await a response

        :returns: (None)
        '''
        command_dict = sensor.send_infrared_message(infrared_code, front_strength, left_strength, right_strength, rear_strength, target=2, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def set_bluetooth_device_name(self, name, timeout=None): 
        '''set_bluetooth_device_name

        :param str name:  
        :param float timeout: maximum time to await a response

        :returns: (None)
        '''
        command_dict = connection.set_bluetooth_device_name(name, target=1, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def get_bluetooth_device_name(self, timeout=None): 
        '''get_bluetooth_device_name

        :param float timeout: maximum time to await a response

        :returns: name(std::string)
        '''
        command_dict = connection.get_bluetooth_device_name(target=1, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def get_bluetooth_advertising_name(self, timeout=None): 
        '''get_bluetooth_advertising_name

        :param float timeout: maximum time to await a response

        :returns: name(std::string)
        '''
        command_dict = connection.get_bluetooth_advertising_name(target=1, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def set_all_leds_with_16_bit_mask(self, led_group, led_brightness_values, timeout=None): 
        '''set_all_leds_with_16_bit_mask

        :param uint16_t led_group: led_groups 
        :param led_brightness_values: 
        :type led_brightness_values: array of uint8_ts (up to 16)
        :param float timeout: maximum time to await a response

        :returns: (None)
        '''
        command_dict = io.set_all_leds_with_16_bit_mask(led_group, led_brightness_values, target=1, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def set_all_leds_with_32_bit_mask(self, led_group, led_brightness_values, timeout=None): 
        '''set_all_leds_with_32_bit_mask

        :param uint32_t led_group: led_groups 
        :param led_brightness_values: Array of RGB values for each of the selected LEDs
        :type led_brightness_values: array of uint8_ts (up to 32)
        :param float timeout: maximum time to await a response

        :returns: (None)
        '''
        command_dict = io.set_all_leds_with_32_bit_mask(led_group, led_brightness_values, target=1, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def set_all_leds_with_64_bit_mask(self, led_group, led_brightness_values, timeout=None): 
        '''set_all_leds_with_64_bit_mask

        :param uint64_t led_group: led_groups 
        :param led_brightness_values: 
        :type led_brightness_values: array of uint8_ts (up to 64)
        :param float timeout: maximum time to await a response

        :returns: (None)
        '''
        command_dict = io.set_all_leds_with_64_bit_mask(led_group, led_brightness_values, target=1, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def set_all_leds_with_8_bit_mask(self, led_group, led_brightness_values, timeout=None): 
        '''set_all_leds_with_8_bit_mask

        :param uint8_t led_group: led_groups 
        :param led_brightness_values: 
        :type led_brightness_values: array of uint8_ts (up to 8)
        :param float timeout: maximum time to await a response

        :returns: (None)
        '''
        command_dict = io.set_all_leds_with_8_bit_mask(led_group, led_brightness_values, target=1, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def set_led_matrix_one_color(self, red, green, blue, timeout=None): 
        '''set_led_matrix_one_color

        :param uint8_t red:  
        :param uint8_t green:  
        :param uint8_t blue:  
        :param float timeout: maximum time to await a response

        :returns: (None)
        '''
        command_dict = io.set_led_matrix_one_color(red, green, blue, target=2, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def save_led_matrix_animation_frame(self, frame_index, color_index_bit_0, color_index_bit_1, color_index_bit_2, color_index_bit_3, timeout=None): 
        '''save_led_matrix_animation_frame

        :param uint16_t frame_index:  
        :param uint64_t color_index_bit_0:  
        :param uint64_t color_index_bit_1:  
        :param uint64_t color_index_bit_2:  
        :param uint64_t color_index_bit_3:  
        :param float timeout: maximum time to await a response

        :returns: (None)
        '''
        command_dict = io.save_led_matrix_animation_frame(frame_index, color_index_bit_0, color_index_bit_1, color_index_bit_2, color_index_bit_3, target=2, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def save_led_matrix_animation(self, animation_index, speed_fps, is_fade_enabled, palette_color_count, palette_rgb_values, frame_count, frame_indexes, timeout=None): 
        '''save_led_matrix_animation

        :param uint8_t animation_index:  
        :param uint8_t speed_fps:  
        :param bool is_fade_enabled:  
        :param uint8_t palette_color_count:  
        :param palette_rgb_values: 
        :type palette_rgb_values: array of uint8_ts (up to 48)
        :param uint16_t frame_count:  
        :param frame_indexes: 
        :type frame_indexes: array of uint16_ts (up to 600)
        :param float timeout: maximum time to await a response

        :returns: (None)
        '''
        command_dict = io.save_led_matrix_animation(animation_index, speed_fps, is_fade_enabled, palette_color_count, palette_rgb_values, frame_count, frame_indexes, target=2, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def play_led_matrix_animation(self, animation_index, timeout=None): 
        '''play_led_matrix_animation

        :param uint8_t animation_index:  
        :param float timeout: maximum time to await a response

        :returns: (None)
        '''
        command_dict = io.play_led_matrix_animation(animation_index, target=2, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def play_led_matrix_animation_frame(self, frame_index, timeout=None): 
        '''play_led_matrix_animation_frame

        :param uint16_t frame_index:  
        :param float timeout: maximum time to await a response

        :returns: (None)
        '''
        command_dict = io.play_led_matrix_animation_frame(frame_index, target=2, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def get_led_matrix_animation_frames(self, timeout=None): 
        '''get_led_matrix_animation_frames

        :param float timeout: maximum time to await a response

        :returns: frame_indexes(uint16_t array)
        '''
        command_dict = io.get_led_matrix_animation_frames(target=2, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def delete_led_matrix_animations_and_frames(self, timeout=None): 
        '''delete_led_matrix_animations_and_frames

        :param float timeout: maximum time to await a response

        :returns: (None)
        '''
        command_dict = io.delete_led_matrix_animations_and_frames(target=2, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def pause_led_matrix(self, timeout=None): 
        '''pause_led_matrix

        :param float timeout: maximum time to await a response

        :returns: (None)
        '''
        command_dict = io.pause_led_matrix(target=2, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def resume_led_matrix(self, timeout=None): 
        '''resume_led_matrix

        :param float timeout: maximum time to await a response

        :returns: (None)
        '''
        command_dict = io.resume_led_matrix(target=2, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def reset_led_matrix(self, timeout=None): 
        '''reset_led_matrix

        :param float timeout: maximum time to await a response

        :returns: (None)
        '''
        command_dict = io.reset_led_matrix(target=2, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def on_led_matrix_animation_complete_notify(self, handler=None, timeout=None): 
        '''led_matrix_animation_complete_notify

        :param coroutine handler: called asynchronously, takes form handler(completeEvent)
        :param float timeout: maximum time to await a response

        :returns: Task (Future) from which `handler` will be called
        '''
        command_dict = io.on_led_matrix_animation_complete_notify(target=2, timeout=timeout)
        command_dict['handler'] = handler
        return asyncio.ensure_future( 
            self._dal.on_command(**command_dict)
        )

    async def assign_frames_to_animation(self, animation_index, start_frame_index, frame_indices, timeout=None): 
        '''assign_frames_to_animation

        :param uint8_t animation_index:  
        :param uint16_t start_frame_index:  
        :param frame_indices: 
        :type frame_indices: array of uint16_ts (up to 150)
        :param float timeout: maximum time to await a response

        :returns: (None)
        '''
        command_dict = io.assign_frames_to_animation(animation_index, start_frame_index, frame_indices, target=2, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def save_led_matrix_animation_without_frames(self, animation_index, speed_fps, is_fade_enabled, palette_color_count, palette_rgb_values, total_frame_count, timeout=None): 
        '''save_led_matrix_animation_without_frames

        :param uint8_t animation_index:  
        :param uint8_t speed_fps:  
        :param bool is_fade_enabled:  
        :param uint8_t palette_color_count:  
        :param palette_rgb_values: 
        :type palette_rgb_values: array of uint8_ts (up to 48)
        :param uint16_t total_frame_count:  
        :param float timeout: maximum time to await a response

        :returns: saved_animations(uint8_t array)
        '''
        command_dict = io.save_led_matrix_animation_without_frames(animation_index, speed_fps, is_fade_enabled, palette_color_count, palette_rgb_values, total_frame_count, target=2, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def play_led_matrix_animation_with_loop_option(self, animation_index, is_looping, timeout=None): 
        '''play_led_matrix_animation_with_loop_option

        :param uint8_t animation_index:  
        :param bool is_looping:  
        :param float timeout: maximum time to await a response

        :returns: (None)
        '''
        command_dict = io.play_led_matrix_animation_with_loop_option(animation_index, is_looping, target=2, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def get_active_color_palette(self, timeout=None): 
        '''get_active_color_palette

        :param float timeout: maximum time to await a response

        :returns: rgb_index_bytes(uint8_t array)
        '''
        command_dict = io.get_active_color_palette(target=1, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def set_active_color_palette(self, rgb_index_bytes, timeout=None): 
        '''set_active_color_palette

        :param rgb_index_bytes: struct array -- index, red, green, blue
        :type rgb_index_bytes: array of uint8_ts (up to 48)
        :param float timeout: maximum time to await a response

        :returns: (None)
        '''
        command_dict = io.set_active_color_palette(rgb_index_bytes, target=1, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def get_color_identification_report(self, red, green, blue, confidence_threshold, timeout=None): 
        '''get_color_identification_report

        :param uint8_t red:  
        :param uint8_t green:  
        :param uint8_t blue:  
        :param uint8_t confidence_threshold:  
        :param float timeout: maximum time to await a response

        :returns: index_confidence_byte(uint8_t array)
        '''
        command_dict = io.get_color_identification_report(red, green, blue, confidence_threshold, target=1, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def load_color_palette(self, palette_index, timeout=None): 
        '''load_color_palette

        :param uint8_t palette_index:  
        :param float timeout: maximum time to await a response

        :returns: (None)
        '''
        command_dict = io.load_color_palette(palette_index, target=1, timeout=timeout)
        return await self._dal.send_command(**command_dict)

    async def save_color_palette(self, palette_index, timeout=None): 
        '''save_color_palette

        :param uint8_t palette_index:  
        :param float timeout: maximum time to await a response

        :returns: (None)
        '''
        command_dict = io.save_color_palette(palette_index, target=1, timeout=timeout)
        return await self._dal.send_command(**command_dict)
