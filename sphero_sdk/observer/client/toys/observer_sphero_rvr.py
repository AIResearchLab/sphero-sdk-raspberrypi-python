#!/usr/bin/env python3
# This file is automatically generated!
# Toy Name:           Sphero RVR
# Prefix:             RV
# Command Count:      56
# Timestamp:          07/09/2019 @ 17:35:38.177737 (UTC)

import logging.config
from sphero_sdk.observer.config import logging_config
from sphero_sdk.common.log_level import LogLevel
from sphero_sdk.observer.observer_base import Observer
from sphero_sdk.observer.client.dal.serial_observer_dal import SerialObserverDal
from sphero_sdk.observer.client.dal.observer_parser import ObserverParser
from sphero_sdk.observer.client.dal.serial_observer_port import SerialObserverPort
from sphero_sdk.observer.events.event_dispatcher import EventDispatcher
from sphero_sdk.common.commands import api_and_shell
from sphero_sdk.common.commands import system_info
from sphero_sdk.common.commands import power
from sphero_sdk.common.commands import drive
from sphero_sdk.common.commands import sensor
from sphero_sdk.common.commands import connection
from sphero_sdk.common.commands import io


class ObserverSpheroRvr(Observer):
    def __init__(self, log_level=LogLevel.Silent):
        logging.config.dictConfig(logging_config.get_dict(log_level))
        Observer.__init__(self)
        dispatcher = EventDispatcher()
        parser = ObserverParser(dispatcher)
        port = SerialObserverPort(parser)
        self._dal = SerialObserverDal(port)

    def close(self):
        self._dal.close()

    def echo(self, data, handler, target, timeout=None):
        '''echo

        :param data: 
        :type data: array of uint8_ts (up to 16)
        :param uint8_t target: 1 or 2
        :param float timeout: maximum time to await a response

        :returns: data(uint8_t array)
        '''
        command_dict = api_and_shell.echo(data, target=target, timeout=timeout)
        self._register_handler(handler, **command_dict)
        self._dal.send_command(**command_dict)

    def get_api_protocol_version(self, handler, target, timeout=None):
        '''get_api_protocol_version

        :param uint8_t target: 1 or 2
        :param float timeout: maximum time to await a response

        :rtype: tuple
        :returns: major_version(uint8_t), minor_version(uint8_t)
        '''
        command_dict = api_and_shell.get_api_protocol_version(target=target, timeout=timeout)
        self._register_handler(handler, **command_dict)
        self._dal.send_command(**command_dict)

    def get_supported_dids(self, handler, target, timeout=None):
        '''get_supported_dids

        :param uint8_t target: 1 or 2
        :param float timeout: maximum time to await a response

        :returns: dids(uint8_t array)
        '''
        command_dict = api_and_shell.get_supported_dids(target=target, timeout=timeout)
        self._register_handler(handler, **command_dict)
        self._dal.send_command(**command_dict)

    def get_supported_cids(self, did, handler, target, timeout=None):
        '''get_supported_cids

        :param uint8_t did:  
        :param uint8_t target: 1 or 2
        :param float timeout: maximum time to await a response

        :returns: cids(uint8_t array)
        '''
        command_dict = api_and_shell.get_supported_cids(did, target=target, timeout=timeout)
        self._register_handler(handler, **command_dict)
        self._dal.send_command(**command_dict)

    def get_main_application_version(self, handler, target, timeout=None):
        '''get_main_application_version

        :param uint8_t target: 1 or 2
        :param float timeout: maximum time to await a response

        :rtype: tuple
        :returns: major(uint16_t), minor(uint16_t), revision(uint16_t)
        '''
        command_dict = system_info.get_main_application_version(target=target, timeout=timeout)
        self._register_handler(handler, **command_dict)
        self._dal.send_command(**command_dict)

    def get_bootloader_version(self, handler, target, timeout=None):
        '''get_bootloader_version

        :param uint8_t target: 1 or 2
        :param float timeout: maximum time to await a response

        :rtype: tuple
        :returns: major(uint16_t), minor(uint16_t), revision(uint16_t)
        '''
        command_dict = system_info.get_bootloader_version(target=target, timeout=timeout)
        self._register_handler(handler, **command_dict)
        self._dal.send_command(**command_dict)

    def get_board_revision(self, handler, target, timeout=None):
        '''get_board_revision

        :param uint8_t target: 1 or 2
        :param float timeout: maximum time to await a response

        :returns: revision(uint8_t)
        '''
        command_dict = system_info.get_board_revision(target=target, timeout=timeout)
        self._register_handler(handler, **command_dict)
        self._dal.send_command(**command_dict)

    def get_mac_address(self, handler, timeout=None):
        '''get_mac_address

        :param float timeout: maximum time to await a response

        :returns: mac_address(std::string)
        '''
        command_dict = system_info.get_mac_address(target=1, timeout=timeout)
        self._register_handler(handler, **command_dict)
        self._dal.send_command(**command_dict)

    def get_nordic_temperature(self, handler, timeout=None):
        '''get_nordic_temperature

        :param float timeout: maximum time to await a response

        :returns: temperature(int32_t array)
        '''
        command_dict = system_info.get_nordic_temperature(target=1, timeout=timeout)
        self._register_handler(handler, **command_dict)
        self._dal.send_command(**command_dict)

    def get_stats_id(self, handler, target, timeout=None):
        '''get_stats_id

        :param uint8_t target: 1 or 2
        :param float timeout: maximum time to await a response

        :returns: stats_id(uint16_t)
        '''
        command_dict = system_info.get_stats_id(target=target, timeout=timeout)
        self._register_handler(handler, **command_dict)
        self._dal.send_command(**command_dict)

    def get_processor_name(self, handler, target, timeout=None):
        '''get_processor_name

        :param uint8_t target: 1 or 2
        :param float timeout: maximum time to await a response

        :returns: name(std::string)
        '''
        command_dict = system_info.get_processor_name(target=target, timeout=timeout)
        self._register_handler(handler, **command_dict)
        self._dal.send_command(**command_dict)

    def get_boot_reason(self, handler, timeout=None):
        '''get_boot_reason

        :param float timeout: maximum time to await a response

        :returns: reason(uint8_t)
        '''
        command_dict = system_info.get_boot_reason(target=1, timeout=timeout)
        self._register_handler(handler, **command_dict)
        self._dal.send_command(**command_dict)

    def get_last_error_info(self, handler, timeout=None):
        '''get_last_error_info

        :param float timeout: maximum time to await a response

        :rtype: tuple
        :returns: file_name(uint8_t array), line_number(uint16_t), data(uint8_t array)
        '''
        command_dict = system_info.get_last_error_info(target=1, timeout=timeout)
        self._register_handler(handler, **command_dict)
        self._dal.send_command(**command_dict)

    def get_manufacturing_date(self, handler, target, timeout=None):
        '''get_manufacturing_date

        :param uint8_t target: 1 or 2
        :param float timeout: maximum time to await a response

        :rtype: tuple
        :returns: year(uint16_t), month(uint8_t), day(uint8_t)
        '''
        command_dict = system_info.get_manufacturing_date(target=target, timeout=timeout)
        self._register_handler(handler, **command_dict)
        self._dal.send_command(**command_dict)

    def get_sku(self, handler, target, timeout=None):
        '''get_sku

        :param uint8_t target: 1 or 2
        :param float timeout: maximum time to await a response

        :returns: sku(std::string)
        '''
        command_dict = system_info.get_sku(target=target, timeout=timeout)
        self._register_handler(handler, **command_dict)
        self._dal.send_command(**command_dict)

    def enter_deep_sleep(self, seconds_until_deep_sleep, timeout=None):
        '''enter_deep_sleep

        :param uint8_t seconds_until_deep_sleep:  seconds
        :param float timeout: maximum time to await a response

        :returns: (None)
        '''
        command_dict = power.enter_deep_sleep(seconds_until_deep_sleep, target=1, timeout=timeout)
        self._dal.send_command(**command_dict)

    def enter_soft_sleep(self, timeout=None):
        '''enter_soft_sleep

        :param float timeout: maximum time to await a response

        :returns: (None)
        '''
        command_dict = power.enter_soft_sleep(target=1, timeout=timeout)
        self._dal.send_command(**command_dict)

    def wake(self, timeout=None):
        '''wake

        :param float timeout: maximum time to await a response

        :returns: (None)
        '''
        command_dict = power.wake(target=1, timeout=timeout)
        self._dal.send_command(**command_dict)

    def get_battery_percentage(self, handler, timeout=None):
        '''get_battery_percentage

        :param float timeout: maximum time to await a response

        :returns: percentage(uint8_t)
        '''
        command_dict = power.get_battery_percentage(target=1, timeout=timeout)
        self._register_handler(handler, **command_dict)
        self._dal.send_command(**command_dict)

    def get_battery_voltage_state(self, handler, timeout=None):
        '''get_battery_voltage_state

        :param float timeout: maximum time to await a response

        :returns: state(uint8_t)
        '''
        command_dict = power.get_battery_voltage_state(target=1, timeout=timeout)
        self._register_handler(handler, **command_dict)
        self._dal.send_command(**command_dict)

    def on_will_sleep_notify(self, handler, timeout=None):
        '''will_sleep_notify

        :param coroutine handler: called asynchronously, takes form handler()
        :param float timeout: maximum time to await a response

        :returns: Task (Future) from which `handler` will be called
        '''
        command_dict = power.on_will_sleep_notify(target=1, timeout=timeout)
        self._register_handler(handler, **command_dict)

    def on_did_sleep_notify(self, handler, timeout=None):
        '''did_sleep_notify

        :param coroutine handler: called asynchronously, takes form handler()
        :param float timeout: maximum time to await a response

        :returns: Task (Future) from which `handler` will be called
        '''
        command_dict = power.on_did_sleep_notify(target=1, timeout=timeout)
        self._register_handler(handler, **command_dict)

    def enable_battery_voltage_state_change_notify(self, is_enabled, timeout=None):
        '''enable_battery_voltage_state_change_notify

        :param bool is_enabled:  
        :param float timeout: maximum time to await a response

        :returns: (None)
        '''
        command_dict = power.enable_battery_voltage_state_change_notify(is_enabled, target=1, timeout=timeout)
        self._dal.send_command(**command_dict)

    def on_battery_voltage_state_change_notify(self, handler, timeout=None):
        '''battery_voltage_state_change_notify

        :param coroutine handler: called asynchronously, takes form handler(state)
        :param float timeout: maximum time to await a response

        :returns: Task (Future) from which `handler` will be called
        '''
        command_dict = power.on_battery_voltage_state_change_notify(target=1, timeout=timeout)
        self._register_handler(handler, **command_dict)

    def raw_motors(self, left_mode, left_speed, right_mode, right_speed, timeout=None):
        '''raw_motors

        :param uint8_t left_mode:  
        :param uint8_t left_speed:  
        :param uint8_t right_mode:  
        :param uint8_t right_speed:  
        :param float timeout: maximum time to await a response

        :returns: (None)
        '''
        command_dict = drive.raw_motors(left_mode, left_speed, right_mode, right_speed, target=2, timeout=timeout)
        self._dal.send_command(**command_dict)

    def reset_yaw(self, timeout=None):
        '''reset_yaw

        :param float timeout: maximum time to await a response

        :returns: (None)
        '''
        command_dict = drive.reset_yaw(target=2, timeout=timeout)
        self._dal.send_command(**command_dict)

    def drive_with_heading(self, speed, heading, flags, timeout=None):
        '''drive_with_heading

        :param uint8_t speed:  
        :param int16_t heading:  
        :param uint8_t flags: drive_flags 
        :param float timeout: maximum time to await a response

        :returns: (None)
        '''
        command_dict = drive.drive_with_heading(speed, heading, flags, target=2, timeout=timeout)
        self._dal.send_command(**command_dict)

    def set_sensor_streaming_mask(self, interval, packet_count, data_mask, timeout=None):
        '''set_sensor_streaming_mask

        :param uint16_t interval:  
        :param uint8_t packet_count:  
        :param uint32_t data_mask:  
        :param float timeout: maximum time to await a response

        :returns: (None)
        '''
        command_dict = sensor.set_sensor_streaming_mask(interval, packet_count, data_mask, target=2, timeout=timeout)
        self._dal.send_command(**command_dict)

    def get_sensor_streaming_mask(self, handler, timeout=None):
        '''get_sensor_streaming_mask

        :param float timeout: maximum time to await a response

        :rtype: tuple
        :returns: interval(uint16_t), packet_count(uint8_t), data_mask(uint32_t)
        '''
        command_dict = sensor.get_sensor_streaming_mask(target=2, timeout=timeout)
        self._register_handler(handler, **command_dict)
        self._dal.send_command(**command_dict)

    def on_sensor_streaming_data_notify(self, handler, timeout=None):
        '''sensor_streaming_data_notify

        :param coroutine handler: called asynchronously, takes form handler(sensorData)
        :param float timeout: maximum time to await a response

        :returns: Task (Future) from which `handler` will be called
        '''
        command_dict = sensor.on_sensor_streaming_data_notify(target=2, timeout=timeout)
        self._register_handler(handler, **command_dict)

    def get_encoder_counts(self, handler, timeout=None):
        '''get_encoder_counts

        :param float timeout: maximum time to await a response

        :returns: encoder_counts(int16_t array)
        '''
        command_dict = sensor.get_encoder_counts(target=2, timeout=timeout)
        self._register_handler(handler, **command_dict)
        self._dal.send_command(**command_dict)

    def get_euler_angles(self, handler, timeout=None):
        '''get_euler_angles

        :param float timeout: maximum time to await a response

        :rtype: tuple
        :returns: pitch(float), roll(float), extended_roll(float), yaw(float)
        '''
        command_dict = sensor.get_euler_angles(target=2, timeout=timeout)
        self._register_handler(handler, **command_dict)
        self._dal.send_command(**command_dict)

    def get_gyro_degrees_per_second(self, handler, timeout=None):
        '''get_gyro_degrees_per_second

        :param float timeout: maximum time to await a response

        :rtype: tuple
        :returns: pitch(float), roll(float), yaw(float)
        '''
        command_dict = sensor.get_gyro_degrees_per_second(target=2, timeout=timeout)
        self._register_handler(handler, **command_dict)
        self._dal.send_command(**command_dict)

    def set_extended_sensor_streaming_mask(self, data_mask, timeout=None):
        '''set_extended_sensor_streaming_mask

        :param uint32_t data_mask:  
        :param float timeout: maximum time to await a response

        :returns: (None)
        '''
        command_dict = sensor.set_extended_sensor_streaming_mask(data_mask, target=2, timeout=timeout)
        self._dal.send_command(**command_dict)

    def get_extended_sensor_streaming_mask(self, handler, timeout=None):
        '''get_extended_sensor_streaming_mask

        :param float timeout: maximum time to await a response

        :returns: data_mask(uint32_t)
        '''
        command_dict = sensor.get_extended_sensor_streaming_mask(target=2, timeout=timeout)
        self._register_handler(handler, **command_dict)
        self._dal.send_command(**command_dict)

    def enable_gyro_max_notify(self, is_enabled, timeout=None):
        '''enable_gyro_max_notify

        :param bool is_enabled:  
        :param float timeout: maximum time to await a response

        :returns: (None)
        '''
        command_dict = sensor.enable_gyro_max_notify(is_enabled, target=2, timeout=timeout)
        self._dal.send_command(**command_dict)

    def on_gyro_max_notify(self, handler, timeout=None):
        '''gyro_max_notify

        :param coroutine handler: called asynchronously, takes form handler(flags)
        :param float timeout: maximum time to await a response

        :returns: Task (Future) from which `handler` will be called
        '''
        command_dict = sensor.on_gyro_max_notify(target=2, timeout=timeout)
        self._register_handler(handler, **command_dict)

    def configure_collision_detection(self, method, x_threshold, x_speed, y_threshold, y_speed, dead_time, timeout=None):
        '''configure_collision_detection

        :param uint8_t method:  
        :param uint8_t x_threshold:  
        :param uint8_t x_speed:  
        :param uint8_t y_threshold:  
        :param uint8_t y_speed:  
        :param uint8_t dead_time:  
        :param float timeout: maximum time to await a response

        :returns: (None)
        '''
        command_dict = sensor.configure_collision_detection(method, x_threshold, x_speed, y_threshold, y_speed, dead_time, target=2, timeout=timeout)
        self._dal.send_command(**command_dict)

    def on_collision_detected_notify(self, handler, timeout=None):
        '''collision_detected_notify

        :param coroutine handler: called asynchronously, takes form handler(accelerationX, accelerationY, accelerationZ, axis, powerX, powerY, speed, time)
        :param float timeout: maximum time to await a response

        :returns: Task (Future) from which `handler` will be called
        '''
        command_dict = sensor.on_collision_detected_notify(target=2, timeout=timeout)
        self._register_handler(handler, **command_dict)

    def get_bot_to_bot_infrared_readings(self, handler, timeout=None):
        '''get_bot_to_bot_infrared_readings

        :param float timeout: maximum time to await a response

        :returns: sensor_data(uint32_t)
        '''
        command_dict = sensor.get_bot_to_bot_infrared_readings(target=2, timeout=timeout)
        self._register_handler(handler, **command_dict)
        self._dal.send_command(**command_dict)

    def start_robot_to_robot_infrared_broadcasting(self, far_code, near_code, timeout=None):
        '''start_robot_to_robot_infrared_broadcasting

        :param uint8_t far_code:  
        :param uint8_t near_code:  
        :param float timeout: maximum time to await a response

        :returns: (None)
        '''
        command_dict = sensor.start_robot_to_robot_infrared_broadcasting(far_code, near_code, target=2, timeout=timeout)
        self._dal.send_command(**command_dict)

    def stop_robot_to_robot_infrared_broadcasting(self, timeout=None):
        '''stop_robot_to_robot_infrared_broadcasting

        :param float timeout: maximum time to await a response

        :returns: (None)
        '''
        command_dict = sensor.stop_robot_to_robot_infrared_broadcasting(target=2, timeout=timeout)
        self._dal.send_command(**command_dict)

    def send_robot_to_robot_infrared_message(self, infrared_code, front_left_strength, front_right_strength, back_right_strength, back_left_strength, timeout=None):
        '''send_robot_to_robot_infrared_message

        :param uint8_t infrared_code:  
        :param uint8_t front_left_strength:  
        :param uint8_t front_right_strength:  
        :param uint8_t back_right_strength:  
        :param uint8_t back_left_strength:  
        :param float timeout: maximum time to await a response

        :returns: (None)
        '''
        command_dict = sensor.send_robot_to_robot_infrared_message(infrared_code, front_left_strength, front_right_strength, back_right_strength, back_left_strength, target=2, timeout=timeout)
        self._dal.send_command(**command_dict)

    def listen_for_robot_to_robot_infrared_message(self, infrared_code, listen_duration, timeout=None):
        '''listen_for_robot_to_robot_infrared_message

        :param uint8_t infrared_code:  
        :param uint32_t listen_duration:  
        :param float timeout: maximum time to await a response

        :returns: (None)
        '''
        command_dict = sensor.listen_for_robot_to_robot_infrared_message(infrared_code, listen_duration, target=2, timeout=timeout)
        self._dal.send_command(**command_dict)

    def on_robot_to_robot_infrared_message_received_notify(self, handler, timeout=None):
        '''robot_to_robot_infrared_message_received_notify

        :param coroutine handler: called asynchronously, takes form handler(infraredCode)
        :param float timeout: maximum time to await a response

        :returns: Task (Future) from which `handler` will be called
        '''
        command_dict = sensor.on_robot_to_robot_infrared_message_received_notify(target=2, timeout=timeout)
        self._register_handler(handler, **command_dict)

    def get_ambient_light_sensor_value(self, handler, timeout=None):
        '''get_ambient_light_sensor_value

        :param float timeout: maximum time to await a response

        :returns: ambient_light_white_channel_value(float)
        '''
        command_dict = sensor.get_ambient_light_sensor_value(target=1, timeout=timeout)
        self._register_handler(handler, **command_dict)
        self._dal.send_command(**command_dict)

    def enable_color_detection_notification(self, enable, interval, minimum_confidence_threshold, timeout=None):
        '''enable_color_detection_notification

        :param bool enable:  
        :param uint16_t interval:  milliseconds
        :param uint8_t minimum_confidence_threshold:  
        :param float timeout: maximum time to await a response

        :returns: (None)
        '''
        command_dict = sensor.enable_color_detection_notification(enable, interval, minimum_confidence_threshold, target=1, timeout=timeout)
        self._dal.send_command(**command_dict)

    def on_color_detection_notify(self, handler, timeout=None):
        '''color_detection_notify

        :param coroutine handler: called asynchronously, takes form handler(red, green, blue, confidence, colorClassification)
        :param float timeout: maximum time to await a response

        :returns: Task (Future) from which `handler` will be called
        '''
        command_dict = sensor.on_color_detection_notify(target=1, timeout=timeout)
        self._register_handler(handler, **command_dict)

    def get_current_detected_color_reading(self, timeout=None):
        '''get_current_detected_color_reading

        :param float timeout: maximum time to await a response

        :returns: (None)
        '''
        command_dict = sensor.get_current_detected_color_reading(target=1, timeout=timeout)
        self._dal.send_command(**command_dict)

    def enable_color_detection(self, enable, timeout=None):
        '''enable_color_detection

        :param bool enable:  
        :param float timeout: maximum time to await a response

        :returns: (None)
        '''
        command_dict = sensor.enable_color_detection(enable, target=1, timeout=timeout)
        self._dal.send_command(**command_dict)

    def set_bluetooth_device_name(self, name, target, timeout=None):
        '''set_bluetooth_device_name

        :param str name:  
        :param uint8_t target: 1 or 2
        :param float timeout: maximum time to await a response

        :returns: (None)
        '''
        command_dict = connection.set_bluetooth_device_name(name, target=target, timeout=timeout)
        self._dal.send_command(**command_dict)

    def get_bluetooth_device_name(self, handler, target, timeout=None):
        '''get_bluetooth_device_name

        :param uint8_t target: 1 or 2
        :param float timeout: maximum time to await a response

        :returns: name(std::string)
        '''
        command_dict = connection.get_bluetooth_device_name(target=target, timeout=timeout)
        self._register_handler(handler, **command_dict)
        self._dal.send_command(**command_dict)

    def set_all_leds_with_32_bit_mask(self, led_group, led_brightness_values, timeout=None):
        '''set_all_leds_with_32_bit_mask

        :param uint32_t led_group: led_groups 
        :param led_brightness_values: 
        :type led_brightness_values: array of uint8_ts (up to 32)
        :param float timeout: maximum time to await a response

        :returns: (None)
        '''
        command_dict = io.set_all_leds_with_32_bit_mask(led_group, led_brightness_values, target=1, timeout=timeout)
        self._dal.send_command(**command_dict)

    def enable_usb_connection_notification(self, enable, timeout=None):
        '''enable_usb_connection_notification

        :param bool enable:  
        :param float timeout: maximum time to await a response

        :returns: (None)
        '''
        command_dict = io.enable_usb_connection_notification(enable, target=2, timeout=timeout)
        self._dal.send_command(**command_dict)

    def on_usb_connection_status_notify(self, handler, timeout=None):
        '''usb_connection_status_notify

        :param coroutine handler: called asynchronously, takes form handler(usbConnectionStatus)
        :param float timeout: maximum time to await a response

        :returns: Task (Future) from which `handler` will be called
        '''
        command_dict = io.on_usb_connection_status_notify(target=2, timeout=timeout)
        self._register_handler(handler, **command_dict)

    def get_usb_connection_status(self, handler, timeout=None):
        '''get_usb_connection_status

        :param float timeout: maximum time to await a response

        :returns: usb_connection_status(uint8_t)
        '''
        command_dict = io.get_usb_connection_status(target=2, timeout=timeout)
        self._register_handler(handler, **command_dict)
        self._dal.send_command(**command_dict)
